# 프로젝트 개요

이번 프로젝트는 사이드 과제형 프로젝트이지만, 단순 기능 구현에 그치지 않고
초기 스타트업 환경에서 빠른 이터레이션 속도로 제품을 개발하는 상황을 가정하여 진행했습니다.

특히, 이번 프로젝트에서는 대시보드 솔루션 서비스의 특성상
각 페이지가 UI와 비즈니스 로직 면에서 완전히 독립적이라고 보기보다는,
여러 페이지에서 재사용할 수 있는 공통 UI 컴포넌트와 데이터 비즈니스 로직이 존재한다고 가정했습니다.
이러한 상황에서 어떤 방식으로 아키텍처를 설계하고 구조화할 수 있을지에 중점을 두었습니다.

- **아키텍처 및 폴더 구조 설계**  
  → 빠른 개발 속도와 향후 확장성, 유지보수성을 동시에 고려할 수 있도록 구조화

## 사용한 기술 스택

- **Next.js App Router**
- **Suspensive** - React Query + Suspense 통합 라이브러리
- **Tailwind CSS**
- **TypeScript**
- **HeroUI** - 디자인 시스템

## 아키텍처/폴더 구조

### 설계 철학

이번 프로젝트의 상위 개요에서 설명드린 것처럼,
각 페이지가 완전히 독립적으로 존재하기보다는 서비스가 고도화되면서 여러 페이지에서 공통으로 활용되는 비즈니스 로직과 UI 컴포넌트가 증가할 것이라 가정하고 진행했습니다.

저는 기존의 단순 역할 기반 분류(components, utils 등)를 넘어서, 서비스를 더 체계적으로 구성할 수 있는 방법을 고민했습니다.
일반적인 프로젝트 구조(components, utils, hooks 중심)는 중규모까지는 무난히 동작하지만, 규모가 커질수록 /components, /hooks, /utils 폴더에 파일이 쌓이고, 이를 재분류하려 하면 프로젝트마다 제각각의 구조가 되어 관리가 어려워집니다.

이 문제는 “역할”이라는 단일 기준만으로 코드를 분류했기 때문입니다.
그러나 실제 프로젝트에는 역할뿐만 아니라 도메인, 기능, 데이터 흐름 등 다양한 관심사가 존재하며, 이를 세밀하게 분리할 필요가 있다고 판단했습니다.

이에 따라 이번 프로젝트에서는 3단계 계층 구조(최상위 계층 → 도메인 레벨 계층 → 구조 단계 계층)를 적용했습니다.
즉, 데이터 처리 로직, 화면(UI), 사용자 상호작용이라는 관심사들이 뒤섞이지 않고 명확히 계층화되도록 설계했습니다.

### 1단계: 최상위 계층 구분

최상위 폴더는 각기 다른 역할(관심사) 를 담당합니다.

```bash
📁 root/app        # Next.js 라우터 (App Router) 진입점
📁 src/app         # 글로벌 스타일, 전역 Provider 관리
📁 src/views       # 페이지 단위 UI + 비즈니스 로직
📁 src/entities    # 데이터 모델, 도메인 비즈니스 로직
📁 src/widgets     # 독립적으로 동작하는 UI 블록
📁 src/shared      # 프로젝트 전반에서 사용하는 유틸리티, 공통 리소스
```

#### 각 폴더명 설명

- views: 개별 페이지 단위. 사용자 행동 흐름(UX)과 직결되는 UI 및 비즈니스 로직 포함
- entities: 데이터 모델 정의 (예: 사용자 인증, 권한 등) 및 핵심 도메인 로직 관리
- widgets: 페이지에 조합되어 쓰이는 UI 블록 (예: 휴대폰 인증 모달, 이벤트 팝업)
- shared: 범용 유틸리티, 공통 상수, 훅 등 프로젝트 전반에서 사용하는 모듈

#### 의존성 규칙

각 폴더는 다음과 같은 방향으로만 의존합니다:

```bash
views → widgets → entities → shared
```

즉, 상위 모듈은 하위 모듈을 참조할 수 있지만, 그 반대는 허용되지 않습니다.
이를 통해 하위 계층일수록 더 안정적이고 범용적이며, 상위 계층은 구체적이고 변경 가능성이 많은 성격을 갖게 됩니다.
추가적으로 같은 계층 간 의존성(entities ↔ entities 등) 도 막았습니다.
이렇게 하면 의존성이 복잡해져 스파게티 코드가 되는 것을 방지하고,
코드 변경 시 영향 범위를 쉽게 예측할 수 있습니다.

#### 2단계: 도메인 레벨 계층 (기능별 구분)

각 폴더 내부는 비즈니스 도메인 단위로 나눕니다.

```bash
📁 entities/
  └── authorization/     # 인증 도메인
📁 views/
  ├── dashboard/         # 대시보드 페이지
  └── home/              # 홈 페이지
📁 widgets/
  ├── 휴대폰 인증 모달/  # 휴대폰 인증 모달 블록
  └── 이벤트 팝업/       # 이벤트 팝업 블록
```

#### 이런식으로 구조화한 이유

- 응집도 향상: 관련된 기능과 파일이 한 곳에 모여 있어 유지보수가 용이
- 확장성 확보: 새로운 도메인 추가 시 기존 코드에 영향 최소화
- 탐색 편의성: 특정 기능을 찾을 때 해당 도메인 폴더만 확인하면 됨

#### Public API

`entitles/authorization` 을 보면 index.ts 가 있습니다. 이게 Public API 입니다.
entitles, widgets, views 에서 Public API를 사용하고 있습니다.
이는 외부에서 해당 모듈을 사용할 때의 진입점역할을 합니다.

```typescript
// 만약 내부 파일 구조를 변경한다고 가정
📁 entities/authorization/
├── hooks/use-auth.tsx     # model/ → hooks/로 이동
└── index.ts

// Public API만 수정하면 됨
- export { useAuth } from "./model/use-auth";
+ export { useAuth } from "./hooks/use-auth";

// 외부 코드는 전혀 수정할 필요 없음
import { useAuth } from "@/src/entities/authorization"; // 동일하게 사용
```

이러한 Public API 패턴을 통해 모듈의 내부 구현은 자유롭게 변경하면서도, 외부와의 인터페이스는 안정적으로 유지할 수 있습니다.

#### 3단계: 구조 단계 계층 (역할별 구분)

각 도메인 폴더 내부는 역할(기술적 목적) 에 따라 다시 나뉩니다.

```ts
📁 views/dashboard/
  ├── api/       # 서버 통신 로직
  ├── model/     # 데이터 타입, 비즈니스 로직
  ├── ui/        # UI 컴포넌트
  └── const/     # 상수 정의

📁 entities/authorization/
  ├── model/     # 도메인 로직, 타입 정의
  ├── api/       # 인증 관련 API
  └── ui/        # 인증 관련 UI

📁 widgets/휴대폰-인증-모달/
  ├── ui/        # 휴대폰 인증 모달 UI 컴포넌트
  ├── model/     # 휴대폰 인증 모달 상태 관리
  └── api/       # 휴대폰 인증 모달 API
```

#### 구조 단계 역할

- api/: 서버와 통신, 데이터 Fetching, Mutation
- model/: 도메인 비즈니스 로직, 상태 관리, 타입 정의
- ui/: UI 컴포넌트
- const/: 상수 정의
- lib/: 해당 도메인 전용 유틸리티

#### 실제 활용 예시

예를 들어 권한(authorization) 모달 UI를 구현한다고 가정하면:

- `entities/authorization/model/` → 권한 관련 비즈니스 로직 및 상태 관리
- `entities/authorization/ui/` → 권한 모달 UI 정의
- `widgets/authorization-modal/` → 여러 페이지에서 공통으로 사용하는 모달 블록
- `views/dashboard/` → Dashboard 페이지에서 모달을 불러와 사용

이렇게 하면, 권한 로직이 바뀌더라도 `entities` 단에서만 수정하면 되고,
`views` 레벨에서는 해당 모달을 그대로 가져다 쓰면 되므로 변경 전파 범위가 최소화됩니다.

#### 정리

이 아키텍처는

1. 최상위 계층 구분 (큰 책임 단위)
2. 도메인 레벨 계층 (기능별 구분)
3. 구조 단계 계층 (역할별 구분)

세 단계를 통해 구성됩니다.

이를 통해 얻을 수 있는 장점은

- 변경에 강한 구조 (데이터 구조 변경이 UI에 최소한의 영향만 줌)
- 재사용성 강화 (공통 로직과 UI widget을 다양한 페이지에서 활용)
- 가독성과 예측 가능성 향상 (폴더 위치만 봐도 코드 역할을 알 수 있음)

## 서버 상태관리 - 비동기/에러 처리 방식

### Suspensive를 선택한 이유

- React의 기본 `Suspense`를 사용할 수도 있지만, Next.js와 같은 서버 사이드 렌더링 환경에서는 예기치 못한 에러가 발생할 수 있습니다.
- 이를 보완하기 위해 SSR 환경에서도 안정적으로 동작하는 **Suspensive**를 도입했습니다.
- **Suspensive**는 TanStack Query + React Suspense를 **선언형으로 사용할 수 있게 해주는 Wrapper**입니다.
- 캐싱과 상태 관리는 TanStack Query가 담당하고, Suspensive는 이를 선언적 패턴으로 사용할 수 있게 해줍니다.
- 또한 서버 상태 관리를 위한 다양한 컴포넌트와 훅을 함께 제공합니다.

### Dashboard 페이지 서버 상태 및 에러 처리 개선

- `src/views/dashboard` 페이지에서 서버 상태 관리를 위해 **Suspensive**를 적용했습니다.

#### SuspenseQuery 적용

- `useSuspenseQuery`를 사용할 경우, Dashboard 컴포넌트 `transaction-table`이나 `user-table`과 같은 하위 컴포넌트 내부에서 훅을 호출해야 합니다.
- 하지만 이 방식은 부모 컴포넌트에서 서버 상태 관리 흐름을 한눈에 파악하기 어렵습니다. 비즈니스 로직이 길어질수록 코드 구조가 더욱 복잡해질 가능성이 있습니다.
- 이를 개선하기 위해 Suspensive의 `SuspenseQuery`를 부모 컴포넌트에서 직접 호출하도록 적용했습니다.
- 이 방식은 `ErrorBoundary`와 `Suspense`가 컴포넌트 트리에서 어떤 범위로 동작하는지 직관적으로 파악할 수 있게 해줍니다.

#### 에러 및 로딩 처리

- `ErrorBoundary`와 `Suspense`를 선언형 컴포넌트로 활용하여 에러 및 로딩 처리를 구성했습니다.
- 이 방식을 사용하면 컴포넌트 내부에서 `try-catch`나 `useEffect`를 통해 에러와 로딩 상태를 직접 관리할 필요가 없습니다.
- 해당 책임을 선언적으로 분리할 수 있어 코드가 단순해지고 가독성이 향상됩니다.

## 개선하고 싶은 부분

다양한 계층에 비즈니스 로직과 UI 컴포넌트가 추가된다면, 아키텍처/폴더 구조가 더 완성도를 더욱 높일 수 있을 것이라 생각합니다.
